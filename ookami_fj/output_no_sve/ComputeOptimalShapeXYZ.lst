Fujitsu C/C++ Version 4.7.0   Wed Nov  9 03:26:39 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/ComputeOptimalShapeXYZ.cpp
(line-no.)(optimize)
        1             
        2             #include <cmath>
        3             #include <cstdlib>
        4             
        5             #include <map>
        6             
        7             #include "ComputeOptimalShapeXYZ.hpp"
        8             #include "MixedBaseCounter.hpp"
        9             
       10             static void
       11             ComputePrimeFactors(int n, std::map<int, int> & factors) {
       12               int d, sq = int((sqrt(double(n)))+1L);
       13               div_t r;
       14             
       15               // remove 2 as a factor with shifts instead "/" and "%"
       16               for (; n > 1 && (n & 1) == 0; n >>= 1) {
       17    i            factors[2]++;
       18               }
       19             
       20               // keep removing subsequent odd numbers
       21               for (d = 3; d <= sq; d += 2) {
       22                 while (1) {
       23                   r = div(n, d);
       24                   if (r.rem == 0) {
       25    i                factors[d]++;
       26                     n = r.quot;
       27                     continue;
       28                   }
       29                   break;
       30                 }
       31               }
       32    i          if (n > 1 || factors.size() == 0)  // left with a prime or x==1
       33    i            factors[n]++;
       34             }
       35             
       36             static int
       37             pow_i(int x, int p) {
       38               int v;
       39             
       40               if (0 == x || 1 == x) return x;
       41             
       42               if (p < 0)
       43                 return 0;
       44             
       45          s    for (v = 1; p; p >>= 1) {
       46                 if (1 & p)
       47                   v *= x;
       48                 x *= x;
       49               }
       50             
       51               return v;
       52             }
       53             
       54             void
       55             ComputeOptimalShapeXYZ(int xyz, int & x, int & y, int & z) {
       56    i          std::map<int, int> factors;
       57             
       58    i          ComputePrimeFactors( xyz, factors ); // factors are sorted: ascending order
       59             
       60    i          std::map<int, int>::iterator iter = factors.begin();
       61             
       62               // there is at least one prime factor
       63    i          x = (iter++)->first; // cache the first factor, move to the next one
       64             
       65    i          y = iter != factors.end() ? (iter++)->first : y; // try to cache the second factor in "y"
       66             
       67    i          if (factors.size() == 1) { // only a single factor
       68    i            z = pow_i(x, factors[x] / 3);
       69    i            y = pow_i(x, factors[x] / 3 + ((factors[x] % 3) >= 2 ? 1 : 0));
       70    i            x = pow_i(x, factors[x] / 3 + ((factors[x] % 3) >= 1 ? 1 : 0));
       71             
       72    i          } else if (factors.size() == 2 && factors[x] == 1 && factors[y] == 1) { // two distinct prime factors
       73                 z = 1;
       74             
       75    i          } else if (factors.size() == 2 && factors[x] + factors[y] == 3) { // three prime factors, one repeated
       76    i            z = factors[x] == 2 ? x : y; // test which factor is repeated
       77             
       78    i          } else if (factors.size() == 3 && factors[x] == 1 && factors[y] == 1 && iter->second == 1) { // three distinct and single prime factors
       79    i            z = iter->first;
       80             
       81               } else { // 3 or more prime factors so try all possible 3-subsets
       82             
       83                 int i, distinct_factors[32+1], count_factors[32+1];
       84             
       85                 i = 0;
       86    i     s      for (std::map<int, int>::iterator iter = factors.begin(); iter != factors.end(); ++iter, ++i) {
       87    i              distinct_factors[i] = iter->first;
       88    i              count_factors[i]    = iter->second;
       89                 }
       90             
       91                 // count total number of prime factors in "c_main" and distribute some factors into "c1"
       92    i            MixedBaseCounter c_main(count_factors, factors.size()), c1(count_factors, factors.size());
       93             
       94                 // at the beginning, minimum area is the maximum area
       95                 double area, min_area = 2.0 * xyz + 1.0;
       96             
       97                 for (c1.next(); ! c1.is_zero(); c1.next()) {
       98                   MixedBaseCounter c2(c_main, c1); // "c2" gets the factors remaining in "c_main" that "c1" doesn't have
       99          s        for (c2.next(); ! c2.is_zero(); c2.next()) {
      100                     int tf1 = c1.product(distinct_factors);
      101                     int tf2 = c2.product(distinct_factors);
      102                     int tf3 = xyz / tf1/ tf2; // we derive the third dimension, we don't keep track of the factors it has
      103             
      104                     area = tf1 * double(tf2) + tf2 * double(tf3) + tf1 * double(tf3);
      105                     if (area < min_area) {
      106                       min_area = area;
      107                       x = tf1;
      108                       y = tf2;
      109                       z = tf3;
      110                     }
      111                   }
      112                 }
      113               }
      114    i        }
