Fujitsu C/C++ Version 4.7.0   Wed Nov  9 03:27:04 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/init.cpp
(line-no.)(optimize)
        1             
        2             //@HEADER
        3             // ***************************************************
        4             //
        5             // HPCG: High Performance Conjugate Gradient Benchmark
        6             //
        7             // Contact:
        8             // Michael A. Heroux ( maherou@sandia.gov)
        9             // Jack Dongarra     (dongarra@eecs.utk.edu)
       10             // Piotr Luszczek    (luszczek@eecs.utk.edu)
       11             //
       12             // ***************************************************
       13             //@HEADER
       14             
       15             #ifndef HPCG_NO_MPI
       16             #include <mpi.h>
       17             #endif
       18             
       19             #ifndef HPCG_NO_OPENMP
       20             #include <omp.h>
       21             #endif
       22             
       23             #ifdef _WIN32
       24             const char* NULLDEVICE="nul";
       25             #else
       26             const char* NULLDEVICE="/dev/null";
       27             #endif
       28             
       29             #include <ctime>
       30             #include <cstdio>
       31             #include <cstdlib>
       32             #include <cstring>
       33             
       34             #include <fstream>
       35             #include <iostream>
       36             
       37             #include "hpcg.hpp"
       38             
       39             #include "ReadHpcgDat.hpp"
       40             
       41             std::ofstream HPCG_fout; //!< output file stream for logging activities during HPCG run
       42             
       43             static int
       44             startswith(const char * s, const char * prefix) {
       45               size_t n = strlen( prefix );
       46               if (strncmp( s, prefix, n ))
       47                 return 0;
       48               return 1;
       49             }
       50             
       51             /*!
       52               Initializes an HPCG run by obtaining problem parameters (from a file or
       53               command line) and then broadcasts them to all nodes. It also initializes
       54               login I/O streams that are used throughout the HPCG run. Only MPI rank 0
       55               performs I/O operations.
       56             
       57               The function assumes that MPI has already been initialized for MPI runs.
       58             
       59               @param[in] argc_p the pointer to the "argc" parameter passed to the main() function
       60               @param[in] argv_p the pointer to the "argv" parameter passed to the main() function
       61               @param[out] params the reference to the data structures that is filled the basic parameters of the run
       62             
       63               @return returns 0 upon success and non-zero otherwise
       64             
       65               @see HPCG_Finalize
       66             */
       67             int
       68             HPCG_Init(int * argc_p, char ** *argv_p, HPCG_Params & params) {
       69               int argc = *argc_p;
       70               char ** argv = *argv_p;
       71               char fname[80];
       72               int i, j, *iparams;
       73               char cparams[][7] = {"--nx=", "--ny=", "--nz=", "--rt=", "--pz=", "--zl=", "--zu=", "--npx=", "--npy=", "--npz=", "--lvt="};
       74               time_t rawtime;
       75               tm * ptm;
       76               const int nparams = (sizeof cparams) / (sizeof cparams[0]);
       77               bool broadcastParams = false; // Make true if parameters read from file.
       78             
       79               iparams = (int *)malloc(sizeof(int) * nparams);
       80             
       81               // Initialize iparams
       82               for (i = 0; i < nparams; ++i) iparams[i] = 0;
       83             
       84               /* for sequential and some MPI implementations it's OK to read first three args */
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
       85         f     for (i = 0; i < nparams; ++i)
       86                 if (argc <= i+1 || sscanf(argv[i+1], "%d", iparams+i) != 1 || iparams[i] < 10) iparams[i] = 0;
       87             
       88               /* for some MPI environments, command line arguments may get complicated so we need a prefix */
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SPILLS :
                       <<<      GENERAL   : SPILL 0  FILL 16
                       <<<      SIMD&FP   : SPILL 0  FILL 0
                       <<<      SCALABLE  : SPILL 0  FILL 0
                       <<<      PREDICATE : SPILL 0  FILL 0
                       <<< Loop-information End >>>
       89          s    for (i = 1; i <= argc && argv[i]; ++i)
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
       90         f       for (j = 0; j < nparams; ++j)
       91    i              if (startswith(argv[i], cparams[j]))
       92                     if (sscanf(argv[i]+strlen(cparams[j]), "%d", iparams+j) != 1)
       93                       iparams[j] = 0;
       94             
       95               // Check if --rt was specified on the command line
       96               int * rt  = iparams+3;  // Assume runtime was not specified and will be read from the hpcg.dat file
       97               if (! iparams[3]) rt = 0; // If --rt was specified, we already have the runtime, so don't read it from file
       98               if (! iparams[0] && ! iparams[1] && ! iparams[2]) { /* no geometry arguments on the command line */
       99                 ReadHpcgDat(iparams, rt, iparams+7);
      100                 broadcastParams = true;
      101               }
      102             
      103               // Check for small or unspecified nx, ny, nz values
      104               // If any dimension is less than 16, make it the max over the other two dimensions, or 16, whichever is largest
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
      105         f     for (i = 0; i < 3; ++i) {
      106                 if (iparams[i] < 16)
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
      107         f         for (j = 1; j <= 2; ++j)
      108                     if (iparams[(i+j)%3] > iparams[i])
      109                       iparams[i] = iparams[(i+j)%3];
      110                 if (iparams[i] < 16)
      111                   iparams[i] = 16;
      112               }
      113             
      114             // Broadcast values of iparams to all MPI processes
      115             #ifndef HPCG_NO_MPI
      116               if (broadcastParams) {
      117                 MPI_Bcast( iparams, nparams, MPI_INT, 0, MPI_COMM_WORLD );
      118               }
      119             #endif
      120             
      121               params.nx = iparams[0];
      122               params.ny = iparams[1];
      123               params.nz = iparams[2];
      124             
      125               params.runningTime = iparams[3];
      126               params.pz = iparams[4];
      127               params.zl = iparams[5];
      128               params.zu = iparams[6];
      129             
      130               params.npx = iparams[7];
      131               params.npy = iparams[8];
      132               params.npz = iparams[9];
      133             
      134             #ifndef HPCG_NO_MPI
      135               MPI_Comm_rank( MPI_COMM_WORLD, &params.comm_rank );
      136               MPI_Comm_size( MPI_COMM_WORLD, &params.comm_size );
      137             #else
      138               params.comm_rank = 0;
      139               params.comm_size = 1;
      140             #endif
      141             
      142             #ifdef HPCG_NO_OPENMP
      143               params.numThreads = 1;
      144             #else
      145               #pragma omp parallel
      146               params.numThreads = omp_get_num_threads();
      147             #endif
      148             //  for (i = 0; i < nparams; ++i) std::cout << "rank = "<< params.comm_rank << " iparam["<<i<<"] = " << iparams[i] << "\n";
      149             
      150               time ( &rawtime );
      151               ptm = localtime(&rawtime);
      152               sprintf( fname, "hpcg%04d%02d%02dT%02d%02d%02d.txt",
      153                   1900 + ptm->tm_year, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec );
      154             
      155               if (0 == params.comm_rank) {
      156    i            HPCG_fout.open(fname);
      157               } else {
      158             #if defined(HPCG_DEBUG) || defined(HPCG_DETAILED_DEBUG)
      159                 sprintf( fname, "hpcg%04d%02d%02dT%02d%02d%02d_%d.txt",
      160                     1900 + ptm->tm_year, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec, params.comm_rank );
      161                 HPCG_fout.open(fname);
      162             #else
      163    i            HPCG_fout.open(NULLDEVICE);
      164             #endif
      165               }
      166               
      167             #if defined(LIKWID_INSTRUMENTATION) || defined(ENABLE_MG_COUNTERS)
      168               if (iparams[10] > 0)
      169               params.lvl_Trace = iparams[10];
      170             #endif
      171             
      172               free( iparams );
      173             
      174               return 0;
      175             }
