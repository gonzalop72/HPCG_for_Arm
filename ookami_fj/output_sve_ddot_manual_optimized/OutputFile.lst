Fujitsu C/C++ Version 4.7.0   Wed Nov  2 16:23:01 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/OutputFile.cpp
(line-no.)(optimize)
        1             
        2             //@HEADER
        3             // ***************************************************
        4             //
        5             // HPCG: High Performance Conjugate Gradient Benchmark
        6             //
        7             // Contact:
        8             // Michael A. Heroux ( maherou@sandia.gov)
        9             // Jack Dongarra     (dongarra@eecs.utk.edu)
       10             // Piotr Luszczek    (luszczek@eecs.utk.edu)
       11             //
       12             // ***************************************************
       13             //@HEADER
       14             
       15             
       16             #include <fstream>
       17             #include <list>
       18             #include <sstream>
       19             #include <string>
       20             
       21             #include "OutputFile.hpp"
       22             
       23             using std::string;
       24             using std::stringstream;
       25             using std::list;
       26             using std::ofstream;
       27             
       28    i        OutputFile::OutputFile(const string & name_arg, const string & version_arg)
       29    i          : name(name_arg), version(version_arg), eol("\n"), keySeparator("::") {}
       30             
       31    i        OutputFile::OutputFile(void) : eol("\n"), keySeparator("::") {}
       32             
       33             OutputFile::~OutputFile() {
       34    i     s    for (list<OutputFile*>::iterator it = descendants.begin(); it != descendants.end(); ++it) {
       35    i            delete *it;
       36               }
       37    i        }
       38             
       39             void
       40             OutputFile::add(const string & key_arg, const string & value_arg) {
       41    i          descendants.push_back(allocKeyVal(key_arg, value_arg));
       42             }
       43             
       44             void
       45             OutputFile::add(const string & key_arg, double value_arg) {
       46    i          stringstream ss;
       47    i          ss << value_arg;
       48    i          descendants.push_back(allocKeyVal(key_arg, ss.str()));
       49    i        }
       50             
       51             void
       52             OutputFile::add(const string & key_arg, int value_arg) {
       53    i          stringstream ss;
       54               ss << value_arg;
       55    i          descendants.push_back(allocKeyVal(key_arg, ss.str()));
       56    i        }
       57             
       58             #ifndef HPCG_NO_LONG_LONG
       59             
       60             void
       61             OutputFile::add(const string & key_arg, long long value_arg) {
       62    i          stringstream ss;
       63    i          ss << value_arg;
       64    i          descendants.push_back(allocKeyVal(key_arg, ss.str()));
       65    i        }
       66             
       67             #endif
       68             
       69             void
       70             OutputFile::add(const string & key_arg, size_t value_arg) {
       71    i          stringstream ss;
       72    i          ss << value_arg;
       73    i          descendants.push_back(allocKeyVal(key_arg, ss.str()));
       74    i        }
       75             
       76             void
       77             OutputFile::setKeyValue(const string & key_arg, const string & value_arg) {
       78    i          key = key_arg;
       79    i          value = value_arg;
       80             }
       81             
       82             OutputFile *
       83             OutputFile::get(const string & key_arg) {
       84    i     s    for (list<OutputFile*>::iterator it = descendants.begin(); it != descendants.end(); ++it) {
       85    i            if ((*it)->key == key_arg)
       86    i              return *it;
       87               }
       88             
       89               return 0;
       90             }
       91             
       92             string
       93             OutputFile::generateRecursive(string prefix) {
       94    i          string result = "";
       95             
       96    i          result += prefix + key + "=" + value + eol;
       97             
       98    i     s    for (list<OutputFile*>::iterator it = descendants.begin(); it != descendants.end(); ++it) {
       99    i            result += (*it)->generateRecursive(prefix + key + keySeparator);
      100               }
      101             
      102               return result;
      103    i        }
      104             
      105             string
      106             OutputFile::generate(void) {
      107    i          string result = name + "\nversion=" + version + eol;
      108             
      109    i     s    for (list<OutputFile*>::iterator it = descendants.begin(); it != descendants.end(); ++it) {
      110    i            result += (*it)->generateRecursive("");
      111               }
      112             
      113               time_t rawtime;
      114               time(&rawtime);
      115               tm * ptm = localtime(&rawtime);
      116               char sdate[25];
      117               //use tm_mon+1 because tm_mon is 0 .. 11 instead of 1 .. 12
      118               sprintf (sdate,"%04d-%02d-%02d_%02d-%02d-%02d",ptm->tm_year + 1900, ptm->tm_mon+1,
      119                     ptm->tm_mday, ptm->tm_hour, ptm->tm_min,ptm->tm_sec);
      120             
      121    i          string filename = name + "_" + version + "_";
      122    i          filename += string(sdate) + ".txt";
      123             
      124    i          ofstream myfile(filename.c_str());
      125    i          myfile << result;
      126    i          myfile.close();
      127             
      128               return result;
      129    i        }
      130             
      131             OutputFile * OutputFile::allocKeyVal(const std::string & key_arg, const std::string & value_arg) {
      132    i          OutputFile * of = new OutputFile();
      133    i          of->setKeyValue(key_arg, value_arg);
      134               return of;
      135             }
