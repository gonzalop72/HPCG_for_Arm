Fujitsu C/C++ Version 4.7.0   Wed Nov  9 16:02:03 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/ComputeSYMGS_ref.cpp
(line-no.)(optimize)
        1             
        2             //@HEADER
        3             // ***************************************************
        4             //
        5             // HPCG: High Performance Conjugate Gradient Benchmark
        6             //
        7             // Contact:
        8             // Michael A. Heroux ( maherou@sandia.gov)
        9             // Jack Dongarra     (dongarra@eecs.utk.edu)
       10             // Piotr Luszczek    (luszczek@eecs.utk.edu)
       11             //
       12             // ***************************************************
       13             //@HEADER
       14             
       15             /*!
       16              @file ComputeSYMGS_ref.cpp
       17             
       18              HPCG routine
       19              */
       20             
       21             #ifndef HPCG_NO_MPI
       22             #include "ExchangeHalo.hpp"
       23             #endif
       24             #include "ComputeSYMGS_ref.hpp"
       25             #include <cassert>
       26             
       27             /*!
       28               Computes one step of symmetric Gauss-Seidel:
       29             
       30               Assumption about the structure of matrix A:
       31               - Each row 'i' of the matrix has nonzero diagonal value whose address is matrixDiagonal[i]
       32               - Entries in row 'i' are ordered such that:
       33                    - lower triangular terms are stored before the diagonal element.
       34                    - upper triangular terms are stored after the diagonal element.
       35                    - No other assumptions are made about entry ordering.
       36             
       37               Symmetric Gauss-Seidel notes:
       38               - We use the input vector x as the RHS and start with an initial guess for y of all zeros.
       39               - We perform one forward sweep.  x should be initially zero on the first GS sweep, but we do not attempt to exploit this fact.
       40               - We then perform one back sweep.
       41               - For simplicity we include the diagonal contribution in the for-j loop, then correct the sum after
       42             
       43               @param[in] A the known system matrix
       44               @param[in] r the input vector
       45               @param[inout] x On entry, x should contain relevant values, on exit x contains the result of one symmetric GS sweep with r as the RHS.
       46             
       47             
       48               @warning Early versions of this kernel (Version 1.1 and earlier) had the r and x arguments in reverse order, and out of sync with other kernels.
       49             
       50               @return returns 0 upon success and non-zero otherwise
       51             
       52               @see ComputeSYMGS
       53             */
       54             int ComputeSYMGS_ref( const SparseMatrix & A, const Vector & r, Vector & x) {
       55             
       56               assert(x.localLength==A.localNumberOfColumns); // Make sure x contain space for halo values
       57             
       58             #ifndef HPCG_NO_MPI
       59               ExchangeHalo(A,x);
       60             #endif
       61             
       62               const local_int_t nrow = A.localNumberOfRows;
       63               double ** matrixDiagonal = A.matrixDiagonal;  // An array of pointers to the diagonal entries A.matrixValues
       64               const double * const rv = r.values;
       65               double * const xv = x.values;
       66             
       67         2     for (local_int_t i=0; i< nrow; i++) {
       68                 const double * const currentValues = A.matrixValues[i];
       69                 const local_int_t * const currentColIndices = A.mtxIndL[i];
       70                 const int currentNumberOfNonzeros = A.nonzerosInRow[i];
       71                 const double  currentDiagonal = matrixDiagonal[i][0]; // Current diagonal value
       72                 double sum = rv[i]; // RHS value
       73             
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: AGNOSTIC; VL: 2 in 128-bit Interleave: 1)
                       <<< Loop-information End >>>
       74          v      for (int j=0; j< currentNumberOfNonzeros; j++) {
       75                   local_int_t curCol = currentColIndices[j];
       76                   sum -= currentValues[j] * xv[curCol];
       77                 }
       78                 sum += xv[i]*currentDiagonal; // Remove diagonal contribution from previous loop
       79             
       80                 xv[i] = sum/currentDiagonal;
       81             
       82               }
       83             
       84               // Now the back sweep.
       85             
       86               for (local_int_t i=nrow-1; i>=0; i--) {
       87                 const double * const currentValues = A.matrixValues[i];
       88                 const local_int_t * const currentColIndices = A.mtxIndL[i];
       89                 const int currentNumberOfNonzeros = A.nonzerosInRow[i];
       90                 const double  currentDiagonal = matrixDiagonal[i][0]; // Current diagonal value
       91                 double sum = rv[i]; // RHS value
       92             
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: AGNOSTIC; VL: 2 in 128-bit Interleave: 1)
                       <<< Loop-information End >>>
       93          v      for (int j = 0; j< currentNumberOfNonzeros; j++) {
       94                   local_int_t curCol = currentColIndices[j];
       95                   sum -= currentValues[j]*xv[curCol];
       96                 }
       97                 sum += xv[i]*currentDiagonal; // Remove diagonal contribution from previous loop
       98             
       99                 xv[i] = sum/currentDiagonal;
      100               }
      101             
      102               return 0;
      103             }
      104             
