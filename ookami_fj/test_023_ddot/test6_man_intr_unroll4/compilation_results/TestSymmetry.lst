Fujitsu C/C++ Version 4.7.0   Wed Nov  9 16:23:10 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/TestSymmetry.cpp
(line-no.)(optimize)
        1             
        2             //@HEADER
        3             // ***************************************************
        4             //
        5             // HPCG: High Performance Conjugate Gradient Benchmark
        6             //
        7             // Contact:
        8             // Michael A. Heroux ( maherou@sandia.gov)
        9             // Jack Dongarra     (dongarra@eecs.utk.edu)
       10             // Piotr Luszczek    (luszczek@eecs.utk.edu)
       11             //
       12             // ***************************************************
       13             //@HEADER
       14             
       15             /*!
       16              @file TestSymmetry.cpp
       17             
       18              HPCG routine
       19              */
       20             
       21             // The MPI include must be first for Windows platforms
       22             #ifndef HPCG_NO_MPI
       23             #include <mpi.h>
       24             #endif
       25             #include <fstream>
       26             #include <iostream>
       27             #include <cfloat>
       28             using std::endl;
       29             #include <vector>
       30             #include <cmath>
       31             
       32             #include "hpcg.hpp"
       33             
       34             #include "ComputeSPMV.hpp"
       35             #include "ComputeMG.hpp"
       36             #include "ComputeDotProduct.hpp"
       37             #include "ComputeResidual.hpp"
       38             #include "Geometry.hpp"
       39             #include "SparseMatrix.hpp"
       40             #include "TestSymmetry.hpp"
       41             
       42             /*!
       43               Tests symmetry-preserving properties of the sparse matrix vector multiply and multi-grid routines.
       44             
       45               @param[in]    geom   The description of the problem's geometry.
       46               @param[in]    A      The known system matrix
       47               @param[in]    b      The known right hand side vector
       48               @param[in]    xexact The exact solution vector
       49               @param[inout] testsymmetry_data The data structure with the results of the CG symmetry test including pass/fail information
       50             
       51               @return returns 0 upon success and non-zero otherwise
       52             
       53               @see ComputeDotProduct
       54               @see ComputeDotProduct_ref
       55               @see ComputeSPMV
       56               @see ComputeSPMV_ref
       57               @see ComputeMG
       58               @see ComputeMG_ref
       59             */
       60             int TestSymmetry(SparseMatrix & A, Vector & b, Vector & xexact, TestSymmetryData & testsymmetry_data) {
       61             
       62              local_int_t nrow = A.localNumberOfRows;
       63              local_int_t ncol = A.localNumberOfColumns;
       64             
       65              Vector x_ncol, y_ncol, z_ncol;
       66    i         InitializeVector(x_ncol, ncol);
       67    i         InitializeVector(y_ncol, ncol);
       68    i         InitializeVector(z_ncol, ncol);
       69             
       70              double t4 = 0.0; // Needed for dot-product call, otherwise unused
       71              testsymmetry_data.count_fail = 0;
       72             
       73              // Test symmetry of matrix
       74             
       75              // First load vectors with random values
       76    i         FillRandomVector(x_ncol);
       77    i         FillRandomVector(y_ncol);
       78             
       79              double xNorm2, yNorm2;
       80              double ANorm = 2 * 26.0;
       81             
       82    i         TraceData tdDisabled;
       83             
       84              // Next, compute x'*A*y
       85              ComputeDotProduct(nrow, y_ncol, y_ncol, yNorm2, t4, A.isDotProductOptimized);
       86              int ierr = ComputeSPMV(A, y_ncol, z_ncol); // z_nrow = A*y_overlap
       87    i         if (ierr) HPCG_fout << "Error in call to SpMV: " << ierr << ".\n" << endl;
       88              double xtAy = 0.0;
       89              ierr = ComputeDotProduct(nrow, x_ncol, z_ncol, xtAy, t4, A.isDotProductOptimized); // x'*A*y
       90    i         if (ierr) HPCG_fout << "Error in call to dot: " << ierr << ".\n" << endl;
       91             
       92              // Next, compute y'*A*x
       93              ComputeDotProduct(nrow, x_ncol, x_ncol, xNorm2, t4, A.isDotProductOptimized);
       94              ierr = ComputeSPMV(A, x_ncol, z_ncol); // b_computed = A*x_overlap
       95    i         if (ierr) HPCG_fout << "Error in call to SpMV: " << ierr << ".\n" << endl;
       96              double ytAx = 0.0;
       97              ierr = ComputeDotProduct(nrow, y_ncol, z_ncol, ytAx, t4, A.isDotProductOptimized); // y'*A*x
       98    i         if (ierr) HPCG_fout << "Error in call to dot: " << ierr << ".\n" << endl;
       99             
      100    i         testsymmetry_data.depsym_spmv = std::fabs((long double) (xtAy - ytAx))/((xNorm2*ANorm*yNorm2 + yNorm2*ANorm*xNorm2) * (DBL_EPSILON));
      101              if (testsymmetry_data.depsym_spmv > 1.0) {
      102               ++testsymmetry_data.count_fail;  // If the difference is > 1, count it wrong
      103    i          HPCG_fout << "Error in Symmetry :: (" << xtAy << "-" << ytAx << ")/(" << xNorm2*ANorm*yNorm2 << "+" << yNorm2*ANorm*xNorm2 << ") * " << DBL_EPSILON << "=" << testsymmetry_data.depsym_spmv <<"\n";
      104              }
      105    i         if (A.geom->rank==0) HPCG_fout << "Departure from symmetry (scaled) for SpMV abs(x'*A*y - y'*A*x) = " << testsymmetry_data.depsym_spmv << endl;
      106             
      107              // Test symmetry of multi-grid
      108             
      109              // Compute x'*Minv*y
      110              ierr = ComputeMG(A, y_ncol, z_ncol, tdDisabled); // z_ncol = Minv*y_ncol
      111    i         if (ierr) HPCG_fout << "Error in call to MG: " << ierr << ".\n" << endl;
      112              double xtMinvy = 0.0;
      113              ierr = ComputeDotProduct(nrow, x_ncol, z_ncol, xtMinvy, t4, A.isDotProductOptimized); // x'*Minv*y
      114    i         if (ierr) HPCG_fout << "Error in call to dot: " << ierr << ".\n" << endl;
      115             
      116              // Next, compute z'*Minv*x
      117              ierr = ComputeMG(A, x_ncol, z_ncol, tdDisabled); // z_ncol = Minv*x_ncol
      118    i         if (ierr) HPCG_fout << "Error in call to MG: " << ierr << ".\n" << endl;
      119              double ytMinvx = 0.0;
      120              ierr = ComputeDotProduct(nrow, y_ncol, z_ncol, ytMinvx, t4, A.isDotProductOptimized); // y'*Minv*x
      121    i         if (ierr) HPCG_fout << "Error in call to dot: " << ierr << ".\n" << endl;
      122             
      123    i         testsymmetry_data.depsym_mg = std::fabs((long double) (xtMinvy - ytMinvx))/((xNorm2*ANorm*yNorm2 + yNorm2*ANorm*xNorm2) * (DBL_EPSILON));
      124              if (testsymmetry_data.depsym_mg > 1.0) {
      125                ++testsymmetry_data.count_fail;  // If the difference is > 1, count it wrong
      126    i          HPCG_fout << "Error in Symmetry(2) :: (" << xtMinvy << "-" << ytMinvx << ")/((" << xNorm2*ANorm*yNorm2 << "+" << yNorm2*ANorm*xNorm2 << ") * " << DBL_EPSILON << ") = " << testsymmetry_data.depsym_mg << "\n";
      127              }
      128    i         if (A.geom->rank==0) HPCG_fout << "Departure from symmetry (scaled) for MG abs(x'*Minv*y - y'*Minv*x) = " << testsymmetry_data.depsym_mg << endl;
      129             
      130    i         CopyVector(xexact, x_ncol); // Copy exact answer into overlap vector
      131             
      132              int numberOfCalls = 2;
      133              double residual = 0.0;
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
      134         f    for (int i=0; i< numberOfCalls; ++i) {
      135                ierr = ComputeSPMV(A, x_ncol, z_ncol); // b_computed = A*x_overlap
      136    i           if (ierr) HPCG_fout << "Error in call to SpMV: " << ierr << ".\n" << endl;
      137                if ((ierr = ComputeResidual(A.localNumberOfRows, b, z_ncol, residual)))
      138    i             HPCG_fout << "Error in call to compute_residual: " << ierr << ".\n" << endl;
      139    i           if (A.geom->rank==0) HPCG_fout << "SpMV call [" << i << "] Residual [" << residual << "]" << endl;
      140              }
      141    i         DeleteVector(x_ncol);
      142    i         DeleteVector(y_ncol);
      143    i         DeleteVector(z_ncol);
      144             
      145              return 0;
      146             }
      147             
