Fujitsu C/C++ Version 4.7.0   Wed Nov  9 16:05:24 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/OptimizeProblem.cpp
(line-no.)(optimize)
        1             /*
        2              *
        3              *  SPDX-License-Identifier: Apache-2.0
        4              *
        5              *  Copyright (C) 2019, Arm Limited and contributors
        6              *
        7              *  Licensed under the Apache License, Version 2.0 (the "License");
        8              *  you may not use this file except in compliance with the License.
        9              *  You may obtain a copy of the License at
       10              *
       11              *      http://www.apache.org/licenses/LICENSE-2.0
       12              *
       13              *  Unless required by applicable law or agreed to in writing, software
       14              *  distributed under the License is distributed on an "AS IS" BASIS,
       15              *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       16              *  See the License for the specific language governing permissions and
       17              *  limitations under the License.
       18              *
       19              */
       20             
       21             
       22             //@HEADER
       23             // ***************************************************
       24             //
       25             // HPCG: High Performance Conjugate Gradient Benchmark
       26             //
       27             // Contact:
       28             // Michael A. Heroux ( maherou@sandia.gov)
       29             // Jack Dongarra     (dongarra@eecs.utk.edu)
       30             // Piotr Luszczek    (luszczek@eecs.utk.edu)
       31             //
       32             // ***************************************************
       33             //@HEADER
       34             
       35             /*!
       36               @file OptimizeProblem.cpp
       37             
       38               HPCG routine
       39               */
       40             
       41             #include "OptimizeProblem.hpp"
       42             #ifdef HPCG_USE_ARMPL_SPMV
       43             #include "armpl_sparse.h"
       44             #endif
       45             
       46             /*!
       47               Optimizes the data structures used for CG iteration to increase the
       48               performance of the benchmark version of the preconditioned CG algorithm.
       49             
       50               @param[inout] A      The known system matrix, also contains the MG hierarchy in attributes Ac and mgData.
       51             
       52               @return returns 0 upon success and non-zero otherwise
       53             
       54               @see GenerateGeometry
       55               @see GenerateProblem
       56               */
       57             int OptimizeCoarseProblem(SparseMatrix & A) {
       58             
       59             	const local_int_t nrow = A.localNumberOfRows;
       60             
       61             	// On the coarse grids we use block coloring algorithm
       62             	A.TDG = false;
       63             
       64             	local_int_t nyPerBlock = 1; // i.e., how many whole-NX is a block
       65             	A.blockSize = A.geom->nx * nyPerBlock;
       66             
       67             	// How many blocks we found in each direction?
       68             	local_int_t blocksInX = 1; // at least, one block has NX rows
       69             	local_int_t blocksInY = A.geom->ny / nyPerBlock;
       70             	local_int_t blocksInZ = A.geom->nz; // blocks cannot contain rows from different X-Y planes
       71             
       72             	local_int_t numberOfBlocks = nrow / A.blockSize;
       73             	A.numberOfBlocks = numberOfBlocks;
       74             
       75             	// Our target is to have two colors per each X-Y plane
       76             	// If not possible, then we will repeat colors at some point
       77             	local_int_t targetNumberOfColors = 2*A.geom->nz;
       78             	if ( A.numberOfBlocks % targetNumberOfColors != 0 ) {
       79             		targetNumberOfColors = A.geom->nz;
       80             	}
       81             
       82             	local_int_t blocksPerColor = A.numberOfBlocks / targetNumberOfColors;
       83             
       84             	// Find a good chunkSize
       85             	if ( blocksPerColor % 4 == 0 ) {
       86             		A.chunkSize = 4;
       87             	} else if ( blocksPerColor % 2 == 0 ) {
       88             		A.chunkSize = 2;
       89             	} else {
       90             		A.chunkSize = 1;
       91             	}
       92             
       93             	assert( blocksPerColor % A.chunkSize == 0);
       94             	assert(A.numberOfBlocks % A.chunkSize == 0);
       95             	assert(targetNumberOfColors % 2 == 0);
       96             
       97    i        	A.firstRowOfBlock = std::vector<local_int_t>(numberOfBlocks);
       98          s  	for ( local_int_t i = 0, ii = 0; i < nrow; i+= A.blockSize, ii++ ) {
       99    i        		A.firstRowOfBlock[ii] = i;
      100             	}
      101             
      102             	// Create an adjacency matrix for the blocked grid
      103             	local_int_t **blockIndices = new local_int_t*[numberOfBlocks];
      104          s  	for ( local_int_t i = 0; i < numberOfBlocks; i++ ) {
      105             		blockIndices[i] = new local_int_t[27];
      106             	}
      107             	local_int_t *nonzerosInBlock = new local_int_t[numberOfBlocks];
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    UNSWITCHING
                       <<< Loop-information End >>>
      108             	for ( local_int_t z = 0; z < blocksInZ; z++ ) {
      109         2s  		for ( local_int_t y = 0; y < blocksInY; y++ ) {
      110             			for ( local_int_t x = 0; x < blocksInX; x++ ) {
      111             				local_int_t curBlock = x + y*blocksInX + z*blocksInX*blocksInY;
      112             				local_int_t *ptr = blockIndices[curBlock];
      113             				local_int_t nnzInBlock = 0;
      114             
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
      115         f   				for ( int zz = -1; zz <= 1; zz++ ) {
      116             					if ( z+zz >= 0 && z+zz < blocksInZ ) {
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
      117         f   						for ( int yy = -1; yy <= 1; yy++ ) {
      118             							if ( y+yy >= 0 && y+yy < blocksInY ) {
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
      119         f   								for ( int xx = -1; xx <= 1; xx++ ) {
      120             									if ( x+xx >= 0 && x+xx < blocksInX ) {
      121             										local_int_t colBlock = curBlock + xx + yy*blocksInX + zz*blocksInX*blocksInY;
      122             										*ptr++ = colBlock;
      123             										nnzInBlock++;
      124             									}
      125             								}
      126             							}
      127             						}
      128             					}
      129             				}
      130             				nonzerosInBlock[curBlock] = nnzInBlock;
      131             			}
      132             		}
      133             	}
      134             
      135             	// We can start coloring
      136    i        	std::vector<local_int_t> colors(numberOfBlocks, numberOfBlocks); // `numberOfBlocks` means uninitialized
      137             	local_int_t totalColors = 1;
      138    i        	colors[0] = 0; // first block gets color 0
      139             
      140             	for ( local_int_t i = 1; i < numberOfBlocks; i++ ) {
      141    i        		if ( colors[i] == numberOfBlocks ) { // if color is not assigned to this block
      142    i        			std::vector<local_int_t> assigned(totalColors, 0);
      143             			local_int_t currentlyAssigned = 0;
      144             			const local_int_t * const currentColIndices = blockIndices[i];
      145             			const int nnz = nonzerosInBlock[i];
      146          s  			for ( local_int_t j = 0; j < nnz; j++ ) {
      147             				local_int_t curCol = currentColIndices[j];
      148             				if ( curCol < i ) { // points beyond i are unassigned, don't about before i
      149    i        					if ( assigned[colors[curCol]] == 0 ) {
      150             						currentlyAssigned++;
      151             					}
      152    i        					assigned[colors[curCol]] = 1;
      153             				} else {
      154             					break; // indices sorted, we can break
      155             				}
      156             			}
      157             			if ( currentlyAssigned < totalColors ) { // if there is at least one color left to use
      158          s  				for ( local_int_t j = 0; j < totalColors; j++ ) {
      159    i        					if ( assigned[j] == 0 ) { // no neighbour block has this color
      160    i        						colors[i] = j;
      161             						break;
      162             					}
      163             				}
      164             			} else { // all colors assigned, create a new one and assign it
      165    i        				colors[i] = totalColors++;
      166             			}
      167    i        		}
      168             	}
      169             
      170             	// Increment the number of colors by changing the colors of some rows
      171             	if ( totalColors < targetNumberOfColors ) {
      172             		local_int_t colorIncrement = targetNumberOfColors - totalColors;
      173             		for ( local_int_t i = 0; i < numberOfBlocks; i += 2*blocksInX*blocksInY ) {
      174             			colorIncrement = colorIncrement == (targetNumberOfColors - totalColors) ? 0 : colorIncrement + 4;
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: AGNOSTIC; VL: 4 in 128-bit Interleave: 1)
                       <<< Loop-information End >>>
      175          v  			for ( local_int_t ii = i; ii < i + 2*blocksInX*blocksInY; ii++ ) {
      176    i        				colors[ii] += colorIncrement;
      177             			}
      178             		}
      179             		totalColors = targetNumberOfColors;
      180             	}
      181             	A.numberOfColors = totalColors;
      182             
      183    i        	std::vector<std::vector<local_int_t> > blocksInColor(totalColors);
      184          s  	for ( local_int_t i = 0; i < numberOfBlocks; i++ ) {
      185    i        		blocksInColor[colors[i]].push_back(i);
      186             	}
      187             
      188    i        	A.numberOfBlocksInColor = std::vector<local_int_t>(totalColors);
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: AGNOSTIC; VL: 2 in 128-bit Interleave: 1)
                       <<< Loop-information End >>>
      189          v  	for ( local_int_t c = 0; c < totalColors; c++ ) {
      190    i        		A.numberOfBlocksInColor[c] = blocksInColor[c].size();
      191             	}
      192             
      193             	// Allocate memory for temporary data structures
      194             	double **matrixValues = new double*[nrow];
      195             	local_int_t **mtxIndL = new local_int_t*[nrow];
      196             	unsigned char *nonzerosInRow = new unsigned char[nrow];
      197          s  	for ( local_int_t i = 0; i < nrow; i++ ) {
      198             		matrixValues[i] = new double[27];
      199             		mtxIndL[i] = new local_int_t[27];
      200             	}
      201             
      202             	// Populate new data structures. Also, merge blocks now
      203             	// We will create the translation vectors on the fly as well
      204    i        	A.whichOldRowIsNewRow = std::vector<local_int_t>(A.localNumberOfColumns);
      205    i        	A.whichNewRowIsOldRow = std::vector<local_int_t>(A.localNumberOfColumns);
      206             	local_int_t ptr = 0;
      207             	for ( local_int_t color = 0; color < totalColors; color++ ) {
      208    i        		for ( local_int_t block = 0; block < blocksInColor[color].size(); block += A.chunkSize ) {
      209             			for ( local_int_t i = 0; i < A.blockSize; i++ ) {
      210             				for ( local_int_t b = 0; b < A.chunkSize; b++ ) {
      211    i        					local_int_t curBlock = blocksInColor[color][block+b];
      212    i        					local_int_t firstRow = A.firstRowOfBlock[curBlock];
      213             					local_int_t curRow = firstRow + i;
      214             
      215          s  					for ( local_int_t j = 0; j < A.nonzerosInRow[curRow]; j++ ) {
      216             						matrixValues[ptr][j] = A.matrixValues[curRow][j];
      217             						mtxIndL[ptr][j] = A.mtxIndL[curRow][j];
      218             					}
      219             					nonzerosInRow[ptr] = A.nonzerosInRow[curRow];
      220    i        					A.whichOldRowIsNewRow[ptr] = curRow;
      221    i        					A.whichNewRowIsOldRow[curRow] = ptr++;
      222             				}
      223             			}
      224             		}
      225             	}
      226             	// External rows are not reordered so they keep the same ID
      227          s  	for ( local_int_t i = nrow; i < A.localNumberOfColumns; i++ ) {
      228    i        		A.whichOldRowIsNewRow[i] = i;
      229    i        		A.whichNewRowIsOldRow[i] = i;
      230             	}
      231             
      232             	// Scan the grid to discover the amount of nonzeros per chunk
      233             	// We already consider the new order
      234             	A.numberOfChunks = nrow / A.chunkSize;
      235    i        	A.nonzerosInChunk = std::vector<local_int_t>(A.numberOfChunks, 0);
      236             	for ( local_int_t i = 0; i < nrow; i+= A.chunkSize ) {
      237             		local_int_t curChunk = i / A.chunkSize;
      238    i        		A.nonzerosInChunk[curChunk] = nonzerosInRow[i];
      239          s  		for ( local_int_t ii = i+1; ii < i+A.chunkSize; ii++ ) {
      240    i        			A.nonzerosInChunk[curChunk] = A.nonzerosInChunk[curChunk] < nonzerosInRow[ii] ? nonzerosInRow[ii] : A.nonzerosInChunk[curChunk];
      241             		}
      242             	}
      243             
      244             	// Translate indices
      245             	for ( local_int_t c = 0; c < A.numberOfChunks; c++ ) {
      246             		for ( local_int_t i = 0; i < A.chunkSize; i++ ) {
      247             			local_int_t curRow = c * A.chunkSize + i;
      248         8s  			for ( local_int_t j = 0; j < nonzerosInRow[curRow]; j++ ) {
      249             				local_int_t curCol = mtxIndL[curRow][j];
      250    i        				mtxIndL[curRow][j] = A.whichNewRowIsOldRow[curCol];
      251             			}
      252             		}
      253             	}
      254             
      255             	// Make sure the values from nonzerosInRow->nonzerosInChunk are actually 0
      256         4   	for ( local_int_t i = 0; i < nrow; i++ ) {
      257             		local_int_t curChunk = i / A.chunkSize;
      258             
      259    i     s  		for ( local_int_t j = nonzerosInRow[i]; j < A.nonzerosInChunk[curChunk]; j++ ) {
      260             			matrixValues[i][j] = 0.0;
      261             			mtxIndL[i][j] = 0;
      262             		}
      263             	}
      264             
      265             	// Regenerate the firstRowOfBlock data structure
      266             	ptr = 0;
      267         4   	for ( local_int_t c = 0; c < totalColors; c++ ) {
      268    i     s  		for ( local_int_t i = 0; i < blocksInColor[c].size(); i++ ) {
      269    i        			A.firstRowOfBlock[blocksInColor[c][i]] =ptr;
      270             			ptr += A.blockSize;
      271             		}
      272             	}
      273             
      274             	// Replace data structures
      275          s  	for ( local_int_t i = 0; i < nrow; i++ ) {
      276             		A.nonzerosInRow[i] = nonzerosInRow[i];
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
      277         f   		for ( local_int_t j = 0; j < 27; j++ ) {
      278             			A.matrixValues[i][j] = matrixValues[i][j];
      279             			A.mtxIndL[i][j] = mtxIndL[i][j];
      280             		}
      281             	}
      282             
      283             	//free(matrixValues);
      284             	//free(mtxIndL);
      285             	//free(nonzerosInRow);
      286             
      287             	// Regenerate the diagonal
      288         4   	for ( local_int_t i = 0; i < nrow; i++ ) {
      289             		local_int_t curChunk = i / A.chunkSize;
      290    i     s  		for ( local_int_t j = 0; j < A.nonzerosInChunk[curChunk]; j++ ) {
      291             			local_int_t curCol = A.mtxIndL[i][j];
      292             			if ( i == curCol ) {
      293             				A.matrixDiagonal[i] = &A.matrixValues[i][j];
      294             				break;
      295             			}
      296             		}
      297             	}
      298             
      299             #ifndef HPCG_NO_MPI
      300             	// Translate row IDs that will be send to neighbours
      301             	for ( local_int_t i = 0; i < A.totalToBeSent; i++ ) {
      302             		local_int_t orig = A.elementsToSend[i];
      303             		A.elementsToSend[i] = A.whichNewRowIsOldRow[orig];
      304             	}
      305             #endif
      306             
      307             #ifdef HPCG_USE_ARMPL_SPMV
      308             	// Now create the temporary data structures that will be copied (flags=0) inside the create call
      309             	local_int_t m = A.localNumberOfRows;
      310             	local_int_t n = A.localNumberOfColumns;
      311             	local_int_t nnz = 0;
      312             	for ( local_int_t i = 0; i < m; i++ ) {
      313             		nnz += A.nonzerosInRow[i];
      314             	}
      315             
      316             	armpl_int_t *row_ptr = (armpl_int_t*) std::malloc((m+1)*sizeof(armpl_int_t));
      317             	armpl_int_t *col_indx = (armpl_int_t*) std::malloc(nnz*sizeof(armpl_int_t));
      318             	double *vals = (double*) std::malloc(nnz*sizeof(double));
      319             
      320             	row_ptr[0] = 0;
      321             	for ( local_int_t i = 0; i < m; i++ ) {
      322             		row_ptr[i+1] = row_ptr[i] + A.nonzerosInRow[i];
      323             	}
      324             
      325             	global_int_t k = 0;
      326             	for ( local_int_t i = 0; i < m; i++ ) {
      327             		for ( local_int_t j = 0; j < A.nonzerosInRow[i]; j++ ) {
      328             			col_indx[k] = A.mtxIndL[i][j];
      329             			vals[k++] = A.matrixValues[i][j];
      330             		}
      331             	}
      332             
      333             	armpl_int_t flags = 0;
      334             	armpl_spmat_create_csr_d(&A.armpl_mat, m, n, row_ptr, col_indx, vals, flags);
      335             
      336             	free(row_ptr);
      337             	free(col_indx);
      338             	free(vals);
      339             
      340             	armpl_spmat_hint(A.armpl_mat, ARMPL_SPARSE_HINT_STRUCTURE, ARMPL_SPARSE_STRUCTURE_HPCG);
      341             	armpl_spmv_optimize(A.armpl_mat);
      342             #endif
      343             
      344             	if ( A.mgData != 0 ) {
      345             		// Translate f2cOperator
      346             		local_int_t ncrow = (A.geom->nx/2) * (A.geom->ny/2) * (A.geom->nz/2);
      347         8s  		for ( local_int_t i = 0; i < ncrow; i++ ) {
      348             			local_int_t orig = A.mgData->f2cOperator[i];
      349    i        			A.mgData->f2cOperator[i] = A.whichNewRowIsOldRow[orig];
      350             		}
      351             		
      352             		return OptimizeCoarseProblem(*A.Ac);
      353             	}
      354             	return 0;
      355             
      356    i        }
      357             
      358             /*!
      359               Optimizes the data structures used for CG iteration to increase the
      360               performance of the benchmark version of the preconditioned CG algorithm.
      361             
      362               @param[inout] A      The known system matrix, also contains the MG hierarchy in attributes Ac and mgData.
      363               @param[inout] data   The data structure with all necessary CG vectors preallocated
      364               @param[inout] b      The known right hand side vector
      365               @param[inout] x      The solution vector to be computed in future CG iteration
      366               @param[inout] xexact The exact solution vector
      367             
      368               @return returns 0 upon success and non-zero otherwise
      369             
      370               @see GenerateGeometry
      371               @see GenerateProblem
      372               */
      373             int OptimizeProblem(SparseMatrix & A, CGData & data, Vector & b, Vector & x, Vector & xexact) {
      374             
      375             	const local_int_t nrow = A.localNumberOfRows;
      376             
      377             	// On the finest grid we use TDG algorithm
      378             	A.TDG = true;
      379             	if (A.TDG) {
      380             
      381             	// Create an auxiliary vector to store the number of dependencies on L for every row
      382             	//unsigned char *nonzerosInLowerDiagonal = (unsigned char*) calloc(nrow, sizeof(nonzerosInLowerDiagonal));
      383    i        	std::vector<unsigned char> nonzerosInLowerDiagonal(nrow, 0);
      384             
      385             	/*
      386             	 * Now populate these vectors. This loop is safe to parallelize
      387             	 */
      388             #ifndef HPCG_NO_OPENMP
      389             #pragma omp parallel for
      390             #endif
      391             	for ( local_int_t i = 0; i < nrow; i++ ) {
      392          s  		for ( local_int_t j = 0; j < A.nonzerosInRow[i]; j++ ) {
      393             			local_int_t curCol = A.mtxIndL[i][j];
      394             			if ( curCol < i && curCol < nrow ) { // check that it's on L and not a row from other domain
      395    i        				nonzerosInLowerDiagonal[i]++;
      396             			} else if ( curCol == i ) { // we found the diagonal, no more L dependencies from here
      397             				break;
      398             			}
      399             		}
      400             	}
      401             
      402             	//local_int_t *depsVisited = (local_int_t*) calloc(nrow, sizeof(local_int_t));
      403             	//unsigned char * processed = (unsigned char*) calloc(nrow, sizeof(local_int_t));
      404    i        	std::vector<local_int_t> depsVisited(nrow, 0);
      405    i        	std::vector<bool> processed(nrow, false);
      406             	local_int_t rowsProcessed = 0;
      407             	
      408             	// Allocate the TDG structure. Starts as an empty matrix
      409    i        	A.tdg = std::vector<std::vector<local_int_t> >();
      410             
      411             	// We start by adding the first row of the grid to the first level. This row has no L dependencies
      412    i        	std::vector<local_int_t> aux(1, 0);
      413    i        	A.tdg.push_back(aux);
      414             
      415             	// Increment the number of dependencies visited for each of the neighbours
      416          s  	for ( local_int_t j = 0; j < A.nonzerosInRow[0]; j++ ) {
      417    i        		if ( A.mtxIndL[0][j] != 0 && A.mtxIndL[0][j] < nrow ) depsVisited[A.mtxIndL[0][j]]++; // don't update deps from other domains
      418             	}
      419    i        	processed[0] = true;
      420             	rowsProcessed++;
      421             
      422             	// Continue with the creation of the TDG
      423             	while ( rowsProcessed < nrow ) {
      424    i        		std::vector<local_int_t> rowsInLevel; // = std::vector<local_int_t>();
      425             
      426             		// Check for the dependencies of the rows of the level before the current one. The dependencies
      427             		// of these rows are the ones that could have their dependencies fulfilled and therefore added to the
      428             		// current level
      429    i        		unsigned int lastLevelOfTDG = A.tdg.size()-1;
      430    i        		for ( local_int_t i = 0; i < A.tdg[lastLevelOfTDG].size(); i++ ) {
      431    i        			local_int_t row = A.tdg[lastLevelOfTDG][i];
      432             
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SPILLS :
                       <<<      GENERAL   : SPILL 4  FILL 10
                       <<<      SIMD&FP   : SPILL 0  FILL 0
                       <<<      SCALABLE  : SPILL 0  FILL 0
                       <<<      PREDICATE : SPILL 0  FILL 0
                       <<< Loop-information End >>>
      433          s  			for ( local_int_t j = 0; j < A.nonzerosInRow[row]; j++ ) {
      434             				local_int_t curCol = A.mtxIndL[row][j];
      435             
      436             				if ( curCol < nrow ) { // don't process external domain rows
      437             					// If this neighbour hasn't been processed yet and all its L dependencies has been processed
      438    i        					if ( !processed[curCol] && depsVisited[curCol] == nonzerosInLowerDiagonal[curCol] ) {
      439    i        						rowsInLevel.push_back(curCol); // add the row to the new level
      440    i        						processed[curCol] = true; // mark the row as processed
      441             					}
      442             				}
      443             			}
      444             		}
      445             
      446             		// Update some information
      447    i        		for ( local_int_t i = 0; i < rowsInLevel.size(); i++ ) {
      448             			rowsProcessed++;
      449    i        			local_int_t row = rowsInLevel[i];
      450          s  			for ( local_int_t j = 0; j < A.nonzerosInRow[row]; j++ ) {
      451             				local_int_t curCol = A.mtxIndL[row][j];
      452             				if ( curCol < nrow && curCol != row ) {
      453    i        					depsVisited[curCol]++;
      454             				}
      455             			}
      456             		}
      457             		
      458             		// Add the just created level to the TDG structure
      459    i        		A.tdg.push_back(rowsInLevel);
      460    i        	}
      461             
      462             	//free(depsVisited);
      463             	//free(nonzerosInLowerDiagonal);
      464             	//free(processed);
      465             
      466             
      467             	// Now we need to create some structures to translate from old and new order (yes, we will reorder the matrix)
      468    i        	A.whichNewRowIsOldRow = std::vector<local_int_t>(A.localNumberOfColumns);
      469    i        	A.whichOldRowIsNewRow = std::vector<local_int_t>(A.localNumberOfColumns);
      470             
      471             	local_int_t oldRow = 0;
      472    i        	for ( local_int_t level = 0; level < A.tdg.size(); level++ ) {
      473    i     s  		for ( local_int_t i = 0; i < A.tdg[level].size(); i++ ) {
      474    i        			local_int_t newRow = A.tdg[level][i];
      475    i        			A.whichOldRowIsNewRow[oldRow] = newRow;
      476    i        			A.whichNewRowIsOldRow[newRow] = oldRow++;
      477             		}
      478             	}
      479             
      480             	// External domain rows are not reordered, thus they keep the same ID
      481          s  	for ( local_int_t i = nrow; i < A.localNumberOfColumns; i++ ) {
      482    i        		A.whichOldRowIsNewRow[i] = i;
      483    i        		A.whichNewRowIsOldRow[i] = i;
      484             	}
      485             
      486             	// Now we need to allocate some structure to temporary allocate the reordered structures
      487             	double **matrixValues = new double*[nrow];
      488             	local_int_t **mtxIndL = new local_int_t*[nrow];
      489             	char *nonzerosInRow = new char[nrow];
      490          s  	for ( local_int_t i = 0; i < nrow; i++ ) {
      491             		matrixValues[i] = new double[27];
      492             		mtxIndL[i] = new local_int_t[27];
      493             	}
      494             
      495             	// And finally we reorder (and translate at the same time)
      496             #ifndef HPCG_NO_OPENMP
      497             #pragma omp parallel for
      498             #endif
      499    i        	for ( local_int_t level = 0; level < A.tdg.size(); level++ ) {
      500    i        		for ( local_int_t i = 0; i < A.tdg[level].size(); i++ ) {
      501    i        			local_int_t oldRow = A.tdg[level][i];
      502    i        			local_int_t newRow = A.whichNewRowIsOldRow[oldRow];
      503             
      504             			nonzerosInRow[newRow] = A.nonzerosInRow[oldRow];
      505          s  			for ( local_int_t j = 0; j < A.nonzerosInRow[oldRow]; j++ ) {
      506             				local_int_t curOldCol = A.mtxIndL[oldRow][j];
      507             				matrixValues[newRow][j] = A.matrixValues[oldRow][j];
      508    i        				mtxIndL[newRow][j] = curOldCol < nrow ? A.whichNewRowIsOldRow[curOldCol] : curOldCol; // don't translate if row is external
      509             			}
      510             		}
      511             	}
      512             
      513             	// time to replace structures
      514             #ifndef HPCG_NO_OPENMP
      515             #pragma omp parallel for
      516             #endif
      517             	for ( local_int_t i = 0; i < nrow; i++ ) {
      518             		A.nonzerosInRow[i] = nonzerosInRow[i];
      519          s  		for ( local_int_t j = 0; j < A.nonzerosInRow[i]; j++ ) {
      520             			A.matrixValues[i][j] = matrixValues[i][j];
      521             			A.mtxIndL[i][j] = mtxIndL[i][j];
      522             		}
      523             		// Put some zeros on padding positions
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: AGNOSTIC; VL: 2 in 128-bit Interleave: 1)
                       <<< Loop-information End >>>
      524          v  		for ( local_int_t j = A.nonzerosInRow[i]; j < 27; j++ ) {
      525             			A.matrixValues[i][j] = 0.0;
      526             			A.mtxIndL[i][j] = 0;
      527             		}
      528             	}
      529             
      530             	//free(matrixValues);
      531             	//free(mtxIndL);
      532             	//free(nonzerosInRow);
      533             
      534             	// Regenerate the diagonal
      535         4   	for ( local_int_t i = 0; i < nrow; i++ ) {
      536          s  		for ( local_int_t j = 0; j < A.nonzerosInRow[i]; j++ ) {
      537             			local_int_t curCol = A.mtxIndL[i][j];
      538             			if ( i == curCol ) {
      539             				A.matrixDiagonal[i] = &A.matrixValues[i][j];
      540             			}
      541             		}
      542             	}
      543             
      544             	// Translate TDG row IDs
      545             	oldRow = 0;
      546    i        	for ( local_int_t l = 0; l < A.tdg.size(); l++ ) {
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: AGNOSTIC; VL: 4 in 128-bit Interleave: 1)
                       <<< Loop-information End >>>
      547    i     v  		for ( local_int_t i = 0; i < A.tdg[l].size(); i++ ) {
      548    i        			A.tdg[l][i] = oldRow++;
      549             		}
      550             	}
      551             
      552             #ifndef HPCG_NO_MPI
      553             	// Translate the row IDs that will be send to other domains
      554             	for ( local_int_t i = 0; i < A.totalToBeSent; i++ ) {
      555             		local_int_t orig = A.elementsToSend[i];
      556             		A.elementsToSend[i] = A.whichNewRowIsOldRow[orig];
      557             	}
      558             #endif
      559             
      560             	// Reorder b (RHS) vector
      561             	Vector bReorder;
      562    i        	InitializeVector(bReorder, b.localLength);
      563    i        	CopyVector(b, bReorder);
      564    i        	CopyAndReorderVector(bReorder, b, A.whichNewRowIsOldRow);
      565             
      566             #ifdef HPCG_USE_ARMPL_SPMV
      567             	// Now create the temporary data structures that will be copied (flags=0) inside the create call
      568             	local_int_t m = A.localNumberOfRows;
      569             	local_int_t n = A.localNumberOfColumns;
      570             	local_int_t nnz = 0;
      571             	for ( local_int_t i = 0; i < m; i++ ) {
      572             		nnz += A.nonzerosInRow[i];
      573             	}
      574             
      575             	armpl_int_t *row_ptr = (armpl_int_t*) std::malloc((m+1)*sizeof(armpl_int_t));
      576             	armpl_int_t *col_indx = (armpl_int_t*) std::malloc(nnz*sizeof(armpl_int_t));
      577             	double *vals = (double*) std::malloc(nnz*sizeof(double));
      578             
      579             	row_ptr[0] = 0;
      580             	for ( local_int_t i = 0; i < m; i++ ) {
      581             		row_ptr[i+1] = row_ptr[i] + A.nonzerosInRow[i];
      582             	}
      583             
      584             	global_int_t k = 0;
      585             	for ( local_int_t i = 0; i < m; i++ ) {
      586             		for ( local_int_t j = 0; j < A.nonzerosInRow[i]; j++ ) {
      587             			col_indx[k] = A.mtxIndL[i][j];
      588             			vals[k++] = A.matrixValues[i][j];
      589             		}
      590             	}
      591             
      592             	armpl_int_t flags = 0;
      593             	armpl_spmat_create_csr_d(&A.armpl_mat, m, n, row_ptr, col_indx, vals, flags);
      594             
      595             	free(row_ptr);
      596             	free(col_indx);
      597             	free(vals);
      598             
      599             	armpl_spmat_hint(A.armpl_mat, ARMPL_SPARSE_HINT_STRUCTURE, ARMPL_SPARSE_STRUCTURE_HPCG);
      600             	armpl_spmv_optimize(A.armpl_mat);
      601             #endif
      602    i        	}
      603             	else {
      604             		OptimizeCoarseProblem(A);
      605             	}
      606             
      607             	if ( A.mgData != 0 ) {
      608             		// Translate f2cOperator values
      609             		local_int_t ncrow = (A.geom->nx/2) * (A.geom->ny/2) * (A.geom->nz/2);
      610         8s  		for ( local_int_t i = 0; i < ncrow; i++ ) {
      611             			local_int_t orig = A.mgData->f2cOperator[i];
      612    i        			A.mgData->f2cOperator[i] = A.whichNewRowIsOldRow[orig];
      613             		}
      614             
      615             		return OptimizeCoarseProblem(*A.Ac);
      616             	}
      617             
      618             	return 0;
      619             }
      620             
      621             // Helper function (see OptimizeProblem.hpp for details)
      622             double OptimizeProblemMemoryUse(const SparseMatrix & A) {
      623             
      624             	return 0.0;
      625             
      626             }
