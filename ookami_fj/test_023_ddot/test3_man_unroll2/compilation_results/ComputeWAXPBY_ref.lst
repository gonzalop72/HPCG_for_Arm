Fujitsu C/C++ Version 4.7.0   Wed Nov  9 16:06:08 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/ComputeWAXPBY_ref.cpp
(line-no.)(optimize)
        1             
        2             //@HEADER
        3             // ***************************************************
        4             //
        5             // HPCG: High Performance Conjugate Gradient Benchmark
        6             //
        7             // Contact:
        8             // Michael A. Heroux ( maherou@sandia.gov)
        9             // Jack Dongarra     (dongarra@eecs.utk.edu)
       10             // Piotr Luszczek    (luszczek@eecs.utk.edu)
       11             //
       12             // ***************************************************
       13             //@HEADER
       14             
       15             /*!
       16              @file ComputeWAXPBY_ref.cpp
       17             
       18              HPCG routine
       19              */
       20             
       21             #include "ComputeWAXPBY_ref.hpp"
       22             #ifndef HPCG_NO_OPENMP
       23             #include <omp.h>
       24             #endif
       25             #include <cassert>
       26             /*!
       27               Routine to compute the update of a vector with the sum of two
       28               scaled vectors where: w = alpha*x + beta*y
       29             
       30               This is the reference WAXPBY impmentation.  It CANNOT be modified for the
       31               purposes of this benchmark.
       32             
       33               @param[in] n the number of vector elements (on this processor)
       34               @param[in] alpha, beta the scalars applied to x and y respectively.
       35               @param[in] x, y the input vectors
       36               @param[out] w the output vector.
       37             
       38               @return returns 0 upon success and non-zero otherwise
       39             
       40               @see ComputeWAXPBY
       41             */
       42             int ComputeWAXPBY_ref(const local_int_t n, const double alpha, const Vector & x,
       43                 const double beta, const Vector & y, Vector & w) {
       44             
       45               assert(x.localLength>=n); // Test vector lengths
       46               assert(y.localLength>=n);
       47             
       48               const double * const xv = x.values;
       49               const double * const yv = y.values;
       50               double * const wv = w.values;
       51             
       52               if (alpha==1.0) {
       53             #ifndef HPCG_NO_OPENMP
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: AGNOSTIC; VL: 2 in 128-bit Interleave: 1)
                       <<< Loop-information End >>>
       54          v      #pragma omp parallel for
       55             #endif
       56                 for (local_int_t i=0; i<n; i++) wv[i] = xv[i] + beta * yv[i];
       57               } else if (beta==1.0) {
       58             #ifndef HPCG_NO_OPENMP
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: AGNOSTIC; VL: 2 in 128-bit Interleave: 1)
                       <<< Loop-information End >>>
       59          v      #pragma omp parallel for
       60             #endif
       61                 for (local_int_t i=0; i<n; i++) wv[i] = alpha * xv[i] + yv[i];
       62               } else  {
       63             #ifndef HPCG_NO_OPENMP
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: AGNOSTIC; VL: 2 in 128-bit Interleave: 1)
                       <<< Loop-information End >>>
       64          v      #pragma omp parallel for
       65             #endif
       66                 for (local_int_t i=0; i<n; i++) wv[i] = alpha * xv[i] + beta * yv[i];
       67               }
       68             
       69               return 0;
       70             }
