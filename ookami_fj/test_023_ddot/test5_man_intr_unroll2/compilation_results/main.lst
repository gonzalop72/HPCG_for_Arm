Fujitsu C/C++ Version 4.7.0   Wed Nov  9 16:15:40 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/main.cpp
(line-no.)(optimize)
        1             
        2             //@HEADER
        3             // ***************************************************
        4             //
        5             // HPCG: High Performance Conjugate Gradient Benchmark
        6             //
        7             // Contact:
        8             // Michael A. Heroux ( maherou@sandia.gov)
        9             // Jack Dongarra     (dongarra@eecs.utk.edu)
       10             // Piotr Luszczek    (luszczek@eecs.utk.edu)
       11             //
       12             // ***************************************************
       13             //@HEADER
       14             
       15             /*!
       16              @file main.cpp
       17             
       18              HPCG routine
       19              */
       20             
       21             // Main routine of a program that calls the HPCG conjugate gradient
       22             // solver to solve the problem, and then prints results.
       23             
       24             #ifndef HPCG_NO_MPI
       25             #include <mpi.h>
       26             #endif
       27             
       28             #include <fstream>
       29             #include <iostream>
       30             #include <cstdlib>
       31             #ifdef HPCG_DETAILED_DEBUG
       32             using std::cin;
       33             #endif
       34             using std::endl;
       35             
       36             #include <vector>
       37             
       38             #include "hpcg.hpp"
       39             
       40             #include "CheckAspectRatio.hpp"
       41             #include "GenerateGeometry.hpp"
       42             #include "GenerateProblem.hpp"
       43             #include "GenerateCoarseProblem.hpp"
       44             #include "SetupHalo.hpp"
       45             #include "CheckProblem.hpp"
       46             #include "ExchangeHalo.hpp"
       47             #include "OptimizeProblem.hpp"
       48             #include "WriteProblem.hpp"
       49             #include "ReportResults.hpp"
       50             #include "mytimer.hpp"
       51             #include "ComputeSPMV_ref.hpp"
       52             #include "ComputeMG_ref.hpp"
       53             #include "ComputeResidual.hpp"
       54             #include "CG.hpp"
       55             #include "CG_ref.hpp"
       56             #include "Geometry.hpp"
       57             #include "SparseMatrix.hpp"
       58             #include "Vector.hpp"
       59             #include "CGData.hpp"
       60             #include "TestCG.hpp"
       61             #include "TestSymmetry.hpp"
       62             #include "TestNorms.hpp"
       63             
       64             #ifdef LIKWID_PERFMON
       65             #include "likwid.h"
       66             #endif
       67             
       68             //#define __PRINT_MATRIX__
       69             #ifdef __PRINT_MATRIX__
       70             #include "print_matrix/PrintMatrix.cpp"
       71             #endif
       72             
       73             #include "InstrumentationData.hpp"
       74             
       75             /*!
       76               Main driver program: Construct synthetic problem, run V&V tests, compute benchmark parameters, run benchmark, report results.
       77             
       78               @param[in]  argc Standard argument count.  Should equal 1 (no arguments passed in) or 4 (nx, ny, nz passed in)
       79               @param[in]  argv Standard argument array.  If argc==1, argv is unused.  If argc==4, argv[1], argv[2], argv[3] will be interpreted as nx, ny, nz, resp.
       80             
       81               @return Returns zero on success and a non-zero value otherwise.
       82             
       83             */
       84             int main(int argc, char * argv[]) {
       85             
       86             #ifdef LIKWID_PERFMON
       87             LIKWID_MARKER_INIT;
       88             #endif
       89             
       90             #pragma omp parallel 
       91             {
       92               //LIKWID_MARKER_THREADINIT; 
       93               #ifdef LIKWID_INSTRUMENTATION
       94               LIKWID_MARKER_REGISTER("cg_spmv");
       95               LIKWID_MARKER_REGISTER("symgs_tdg");
       96               LIKWID_MARKER_REGISTER("spmv_tdg");
       97               LIKWID_MARKER_REGISTER("rest_tdg");
       98               LIKWID_MARKER_REGISTER("prol_tdg");
       99               LIKWID_MARKER_REGISTER("symgs2_tdg");
      100               LIKWID_MARKER_REGISTER("symgs_bl");
      101               LIKWID_MARKER_REGISTER("spmv_bl");
      102               LIKWID_MARKER_REGISTER("rest_bl");
      103               LIKWID_MARKER_REGISTER("prol_bl");
      104               LIKWID_MARKER_REGISTER("symgs2_bl");
      105               #endif
      106             }
      107             
      108             #ifndef HPCG_NO_MPI
      109               MPI_Init(&argc, &argv);
      110             #endif
      111             
      112    i          HPCG_Params params;
      113             
      114               HPCG_Init(&argc, &argv, params);
      115             
      116               // Check if QuickPath option is enabled.
      117               // If the running time is set to zero, we minimize all paths through the program
      118               bool quickPath = (params.runningTime==0);
      119             
      120               int size = params.comm_size, rank = params.comm_rank; // Number of MPI processes, My process ID
      121             
      122             #ifdef HPCG_DETAILED_DEBUG
      123               if (size < 100 && rank==0) HPCG_fout << "Process "<<rank<<" of "<<size<<" is alive with " << params.numThreads << " threads." <<endl;
      124             
      125               if (rank==0) {
      126                 char c;
      127                 std::cout << "Press key to continue"<< std::endl;
      128                 std::cin.get(c);
      129               }
      130             #ifndef HPCG_NO_MPI
      131               MPI_Barrier(MPI_COMM_WORLD);
      132             #endif
      133             #endif
      134             
      135               local_int_t nx,ny,nz;
      136               nx = (local_int_t)params.nx;
      137               ny = (local_int_t)params.ny;
      138               nz = (local_int_t)params.nz;
      139               int ierr = 0;  // Used to check return codes on function calls
      140             
      141               ierr = CheckAspectRatio(0.125, nx, ny, nz, "local problem", rank==0);
      142               if (ierr)
      143                 return ierr;
      144             
      145               /////////////////////////
      146               // Problem setup Phase //
      147               /////////////////////////
      148             
      149             #ifdef HPCG_DEBUG
      150               double t1 = mytimer();
      151             #endif
      152             
      153               // Construct the geometry and linear system
      154               Geometry * geom = new Geometry;
      155               GenerateGeometry(size, rank, params.numThreads, params.pz, params.zl, params.zu, nx, ny, nz, params.npx, params.npy, params.npz, geom);
      156             
      157               ierr = CheckAspectRatio(0.125, geom->npx, geom->npy, geom->npz, "process grid", rank==0);
      158               if (ierr)
      159                 return ierr;
      160             
      161               // Use this array for collecting timing information
      162    i          std::vector< double > times(10,0.0);
      163             
      164               double setup_time = mytimer();
      165             
      166    i          SparseMatrix A;
      167    i          InitializeSparseMatrix(A, geom);
      168             
      169               Vector b, x, xexact;
      170               GenerateProblem(A, &b, &x, &xexact);
      171               SetupHalo(A);
      172               int numberOfMgLevels = 4; // Number of levels including first
      173               SparseMatrix * curLevelMatrix = &A;
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
      174         f     for (int level = 1; level< numberOfMgLevels; ++level) {
      175                 GenerateCoarseProblem(*curLevelMatrix, level);
      176                 curLevelMatrix = curLevelMatrix->Ac; // Make the just-constructed coarse grid the next level
      177               }
      178             
      179               setup_time = mytimer() - setup_time; // Capture total time of setup
      180    i          times[9] = setup_time; // Save it for reporting
      181             
      182               curLevelMatrix = &A;
      183               Vector * curb = &b;
      184               Vector * curx = &x;
      185               Vector * curxexact = &xexact;
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    FULL UNROLLING
                       <<< Loop-information End >>>
      186         f     for (int level = 0; level< numberOfMgLevels; ++level) {
      187                  CheckProblem(*curLevelMatrix, curb, curx, curxexact);
      188                  curLevelMatrix = curLevelMatrix->Ac; // Make the nextcoarse grid the next level
      189                  curb = 0; // No vectors after the top level
      190                  curx = 0;
      191                  curxexact = 0;
      192               }
      193             
      194             
      195               CGData data;
      196    i          InitializeSparseCGData(A, data);
      197             
      198             
      199             
      200               ////////////////////////////////////
      201               // Reference SpMV+MG Timing Phase //
      202               ////////////////////////////////////
      203             
      204               // Call Reference SpMV and MG. Compute Optimization time as ratio of times in these routines
      205             
      206               local_int_t nrow = A.localNumberOfRows;
      207               local_int_t ncol = A.localNumberOfColumns;
      208             
      209               Vector x_overlap, b_computed;
      210    i          InitializeVector(x_overlap, ncol); // Overlapped copy of x vector
      211    i          InitializeVector(b_computed, nrow); // Computed RHS vector
      212             
      213             
      214               // Record execution time of reference SpMV and MG kernels for reporting times
      215               // First load vector with random values
      216    i          FillRandomVector(x_overlap);
      217             
      218               int numberOfCalls = 10;
      219               if (quickPath) numberOfCalls = 1; //QuickPath means we do on one call of each block of repetitive code
      220               double t_begin = mytimer();
      221          s    for (int i=0; i< numberOfCalls; ++i) {
      222                 ierr = ComputeSPMV_ref(A, x_overlap, b_computed); // b_computed = A*x_overlap
      223    i            if (ierr) HPCG_fout << "Error in call to SpMV: " << ierr << ".\n" << endl;
      224                 ierr = ComputeMG_ref(A, b_computed, x_overlap); // b_computed = Minv*y_overlap
      225    i            if (ierr) HPCG_fout << "Error in call to MG: " << ierr << ".\n" << endl;
      226               }
      227    i          times[8] = (mytimer() - t_begin)/((double) numberOfCalls);  // Total time divided by number of calls.
      228             #ifdef HPCG_DEBUG
      229               if (rank==0) HPCG_fout << "Total SpMV+MG timing phase execution time in main (sec) = " << mytimer() - t1 << endl;
      230             #endif
      231             
      232               ///////////////////////////////
      233               // Reference CG Timing Phase //
      234               ///////////////////////////////
      235             
      236             #ifdef HPCG_DEBUG
      237               t1 = mytimer();
      238             #endif
      239               int global_failure = 0; // assume all is well: no failures
      240             
      241               int niters = 0;
      242               int totalNiters_ref = 0;
      243               double normr = 0.0;
      244               double normr0 = 0.0;
      245               int refMaxIters = 50;
      246               numberOfCalls = 1; // Only need to run the residual reduction analysis once
      247             
      248               // Compute the residual reduction for the natural ordering and reference kernels
      249    i          std::vector< double > ref_times(9,0.0);
      250               double tolerance = 0.0; // Set tolerance to zero to make all runs do maxIters iterations
      251               int err_count = 0;
      252               for (int i=0; i< numberOfCalls; ++i) {
      253    i            ZeroVector(x);
      254    i            ierr = CG_ref( A, data, b, x, refMaxIters, tolerance, niters, normr, normr0, &ref_times[0], true);
      255                 if (ierr) ++err_count; // count the number of errors in CG
      256                 totalNiters_ref += niters;
      257               }
      258    i          if (rank == 0 && err_count) HPCG_fout << err_count << " error(s) in call(s) to reference CG." << endl;
      259               double refTolerance = normr / normr0;
      260             
      261             #ifdef __PRINT_MATRIX__
      262               PrintMatrixMarket(A, "original.mtx");
      263             #endif
      264               // Call user-tunable set up function.
      265               double t7 = mytimer();
      266               OptimizeProblem(A, data, b, x, xexact);
      267               t7 = mytimer() - t7;
      268    i          times[7] = t7;
      269             #ifdef HPCG_DEBUG
      270               if (rank==0) HPCG_fout << "Total problem setup time in main (sec) = " << mytimer() - t1 << endl;
      271             #endif
      272             
      273             #ifdef HPCG_DETAILED_DEBUG
      274               if (geom->size == 1) WriteProblem(*geom, A, b, x, xexact);
      275             #endif
      276             
      277             #ifdef __PRINT_MATRIX__
      278               char const * filename = "range.txt";
      279               PrintMatrixMarket(A, "optimized.mtx");
      280               //PrintRangeMatrx(A, filename, 144*144*144/2 -50, 144*144*144/2 + 50);
      281             #endif
      282             
      283               //////////////////////////////
      284               // Validation Testing Phase //
      285               //////////////////////////////
      286             
      287             #ifdef HPCG_DEBUG
      288               t1 = mytimer();
      289             #endif
      290               TestCGData testcg_data;
      291               testcg_data.count_pass = testcg_data.count_fail = 0;
      292               TestCG(A, data, b, x, testcg_data);
      293             
      294               TestSymmetryData testsymmetry_data;
      295               TestSymmetry(A, b, xexact, testsymmetry_data);
      296             
      297             #ifdef HPCG_DEBUG
      298               if (rank==0) HPCG_fout << "Total validation (TestCG and TestSymmetry) execution time in main (sec) = " << mytimer() - t1 << endl;
      299             #endif
      300             
      301             #ifdef HPCG_DEBUG
      302               t1 = mytimer();
      303             #endif
      304             
      305               //////////////////////////////
      306               // Optimized CG Setup Phase //
      307               //////////////////////////////
      308             
      309               niters = 0;
      310               normr = 0.0;
      311               normr0 = 0.0;
      312               err_count = 0;
      313               int tolerance_failures = 0;
      314             
      315               int optMaxIters = 10*refMaxIters;
      316               int optNiters = refMaxIters;
      317               double opt_worst_time = 0.0;
      318             
      319    i          TraceData tdDisabled;
      320             
      321    i          std::vector< double > opt_times(9,0.0);
      322             
      323               // Compute the residual reduction and residual count for the user ordering and optimized kernels.
      324               for (int i=0; i< numberOfCalls; ++i) {
      325    i            ZeroVector(x); // start x at all zeros
      326    i            double last_cummulative_time = opt_times[0];
      327    i            ierr = CG( A, data, b, x, optMaxIters, refTolerance, niters, normr, normr0, &opt_times[0], true, tdDisabled);
      328                 if (ierr) ++err_count; // count the number of errors in CG
      329                 if (normr / normr0 > refTolerance) ++tolerance_failures; // the number of failures to reduce residual
      330             
      331                 // pick the largest number of iterations to guarantee convergence
      332                 if (niters > optNiters) optNiters = niters;
      333             
      334    i            double current_time = opt_times[0] - last_cummulative_time;
      335                 if (current_time > opt_worst_time) opt_worst_time = current_time;
      336               }
      337             
      338             #ifndef HPCG_NO_MPI
      339             // Get the absolute worst time across all MPI ranks (time in CG can be different)
      340               double local_opt_worst_time = opt_worst_time;
      341               MPI_Allreduce(&local_opt_worst_time, &opt_worst_time, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
      342             #endif
      343             
      344             
      345    i          if (rank == 0 && err_count) HPCG_fout << err_count << " error(s) in call(s) to optimized CG." << endl;
      346               if (tolerance_failures) {
      347                 global_failure = 1;
      348                 if (rank == 0)
      349    i              HPCG_fout << "Failed to reduce the residual " << tolerance_failures << " times." << endl;
      350               }
      351             
      352               ///////////////////////////////
      353               // Optimized CG Timing Phase //
      354               ///////////////////////////////
      355             
      356               // Here we finally run the benchmark phase
      357               // The variable total_runtime is the target benchmark execution time in seconds
      358             
      359               double total_runtime = params.runningTime;
      360               int numberOfCgSets = int(total_runtime / opt_worst_time) + 1; // Run at least once, account for rounding
      361             
      362             #ifdef HPCG_DEBUG
      363               if (rank==0) {
      364                 HPCG_fout << "Projected running time: " << total_runtime << " seconds" << endl;
      365                 HPCG_fout << "Number of CG sets: " << numberOfCgSets << endl;
      366               }
      367             #endif
      368             
      369               /* This is the timed run for a specified amount of time. */
      370             
      371               optMaxIters = optNiters;
      372               double optTolerance = 0.0;  // Force optMaxIters iterations
      373               TestNormsData testnorms_data;
      374               testnorms_data.samples = numberOfCgSets;
      375               testnorms_data.values = new double[numberOfCgSets];
      376             
      377    i          TraceData tdEnabled; 
      378               tdEnabled.enabled = true;
      379               tdEnabled.level = params.lvl_Trace;
      380             
      381          s    for (int i=0; i< numberOfCgSets; ++i) {
      382    i            ZeroVector(x); // Zero out x
      383    i            ierr = CG( A, data, b, x, optMaxIters, optTolerance, niters, normr, normr0, &times[0], true, tdEnabled);
      384    i            if (ierr) HPCG_fout << "Error in call to CG: " << ierr << ".\n" << endl;
      385    i            if (rank==0) HPCG_fout << "Call [" << i << "] Scaled Residual [" << normr/normr0 << "]" << endl;
      386                 testnorms_data.values[i] = normr/normr0; // Record scaled residual from this run
      387               }
      388             
      389               // Compute difference between known exact solution and computed solution
      390               // All processors are needed here.
      391             #ifdef HPCG_DEBUG
      392               double residual = 0;
      393               ierr = ComputeResidual(A.localNumberOfRows, x, xexact, residual);
      394               if (ierr) HPCG_fout << "Error in call to compute_residual: " << ierr << ".\n" << endl;
      395               if (rank==0) HPCG_fout << "Difference between computed and exact  = " << residual << ".\n" << endl;
      396             #endif
      397             
      398               // Test Norm Results
      399               ierr = TestNorms(testnorms_data);
      400             
      401               ////////////////////
      402               // Report Results //
      403               ////////////////////
      404             
      405               // Report results to YAML file
      406    i          ReportResults(A, numberOfMgLevels, numberOfCgSets, refMaxIters, optMaxIters, &times[0], testcg_data, testsymmetry_data, testnorms_data, global_failure, quickPath);
      407             
      408               // Clean up
      409               DeleteMatrix(A); // This delete will recursively delete all coarse grid data
      410    i          DeleteCGData(data);
      411    i          DeleteVector(x);
      412    i          DeleteVector(b);
      413    i          DeleteVector(xexact);
      414    i          DeleteVector(x_overlap);
      415    i          DeleteVector(b_computed);
      416               delete [] testnorms_data.values;
      417             
      418             
      419             
      420               HPCG_Finalize();
      421             
      422               // Finish up
      423             #ifndef HPCG_NO_MPI
      424               MPI_Finalize();
      425             #endif
      426             
      427             #ifdef LIKWID_PERFMON
      428               LIKWID_MARKER_CLOSE;
      429             #endif
      430             
      431               return 0;
      432    i        }
