Fujitsu C/C++ Version 4.7.0   Wed Nov  2 15:04:31 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/ComputeMG_ref.cpp
(line-no.)(optimize)
        1             
        2             //@HEADER
        3             // ***************************************************
        4             //
        5             // HPCG: High Performance Conjugate Gradient Benchmark
        6             //
        7             // Contact:
        8             // Michael A. Heroux ( maherou@sandia.gov)
        9             // Jack Dongarra     (dongarra@eecs.utk.edu)
       10             // Piotr Luszczek    (luszczek@eecs.utk.edu)
       11             //
       12             // ***************************************************
       13             //@HEADER
       14             
       15             /*!
       16              @file ComputeSYMGS_ref.cpp
       17             
       18              HPCG routine
       19              */
       20             
       21             #include "ComputeMG_ref.hpp"
       22             #include "ComputeSYMGS_ref.hpp"
       23             #include "ComputeSPMV_ref.hpp"
       24             #include "ComputeRestriction_ref.hpp"
       25             #include "ComputeProlongation_ref.hpp"
       26             #include <cassert>
       27             #include <iostream>
       28             
       29             /*!
       30             
       31               @param[in] A the known system matrix
       32               @param[in] r the input vector
       33               @param[inout] x On exit contains the result of the multigrid V-cycle with r as the RHS, x is the approximation to Ax = r.
       34             
       35               @return returns 0 upon success and non-zero otherwise
       36             
       37               @see ComputeMG
       38             */
       39             int ComputeMG_ref(const SparseMatrix & A, const Vector & r, Vector & x) {
       40               assert(x.localLength==A.localNumberOfColumns); // Make sure x contain space for halo values
       41             
       42    i          ZeroVector(x); // initialize x to zero
       43             
       44               int ierr = 0;
       45               if (A.mgData!=0) { // Go to next coarse level if defined
       46                 int numberOfPresmootherSteps = A.mgData->numberOfPresmootherSteps;
       47          s      for (int i=0; i< numberOfPresmootherSteps; ++i) ierr += ComputeSYMGS_ref(A, r, x);
       48                 if (ierr!=0) return ierr;
       49                 ierr = ComputeSPMV_ref(A, x, *A.mgData->Axf); if (ierr!=0) return ierr;
       50                 // Perform restriction operation using simple injection
       51                 ierr = ComputeRestriction_ref(A, r);  if (ierr!=0) return ierr;
       52                 ierr = ComputeMG_ref(*A.Ac,*A.mgData->rc, *A.mgData->xc);  if (ierr!=0) return ierr;
       53                 ierr = ComputeProlongation_ref(A, x);  if (ierr!=0) return ierr;
       54                 int numberOfPostsmootherSteps = A.mgData->numberOfPostsmootherSteps;
       55          s      for (int i=0; i< numberOfPostsmootherSteps; ++i) ierr += ComputeSYMGS_ref(A, r, x);
       56                 if (ierr!=0) return ierr;
       57               }
       58               else {
       59                 ierr = ComputeSYMGS_ref(A, r, x);
       60                 if (ierr!=0) return ierr;
       61               }
       62               return 0;
       63             }
       64             
