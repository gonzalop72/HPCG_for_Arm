Fujitsu C/C++ Version 4.7.0   Fri Nov 11 03:48:18 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/ComputeSPMV_ref.cpp
(line-no.)(optimize)
        1             
        2             //@HEADER
        3             // ***************************************************
        4             //
        5             // HPCG: High Performance Conjugate Gradient Benchmark
        6             //
        7             // Contact:
        8             // Michael A. Heroux ( maherou@sandia.gov)
        9             // Jack Dongarra     (dongarra@eecs.utk.edu)
       10             // Piotr Luszczek    (luszczek@eecs.utk.edu)
       11             //
       12             // ***************************************************
       13             //@HEADER
       14             
       15             /*!
       16              @file ComputeSPMV_ref.cpp
       17             
       18              HPCG routine
       19              */
       20             
       21             #include "ComputeSPMV_ref.hpp"
       22             
       23             #ifndef HPCG_NO_MPI
       24             #include "ExchangeHalo.hpp"
       25             #endif
       26             
       27             #ifndef HPCG_NO_OPENMP
       28             #include <omp.h>
       29             #endif
       30             #include <cassert>
       31             
       32             /*!
       33               Routine to compute matrix vector product y = Ax where:
       34               Precondition: First call exchange_externals to get off-processor values of x
       35             
       36               This is the reference SPMV implementation.  It CANNOT be modified for the
       37               purposes of this benchmark.
       38             
       39               @param[in]  A the known system matrix
       40               @param[in]  x the known vector
       41               @param[out] y the On exit contains the result: Ax.
       42             
       43               @return returns 0 upon success and non-zero otherwise
       44             
       45               @see ComputeSPMV
       46             */
       47             int ComputeSPMV_ref( const SparseMatrix & A, Vector & x, Vector & y) {
       48             
       49               assert(x.localLength>=A.localNumberOfColumns); // Test vector lengths
       50               assert(y.localLength>=A.localNumberOfRows);
       51             
       52             #ifndef HPCG_NO_MPI
       53                 ExchangeHalo(A,x);
       54             #endif
       55               const double * const xv = x.values;
       56               double * const yv = y.values;
       57               const local_int_t nrow = A.localNumberOfRows;
       58             #ifndef HPCG_NO_OPENMP
       59               #pragma omp parallel for
       60             #endif
       61               for (local_int_t i=0; i< nrow; i++)  {
       62                 double sum = 0.0;
       63                 const double * const cur_vals = A.matrixValues[i];
       64                 const local_int_t * const cur_inds = A.mtxIndL[i];
       65                 const int cur_nnz = A.nonzerosInRow[i];
       66             
                       <<< Loop-information Start >>>
                       <<<  [OPTIMIZATION]
                       <<<    SIMD(VL: AGNOSTIC; VL: 2 in 128-bit Interleave: 1)
                       <<< Loop-information End >>>
       67          v      for (int j=0; j< cur_nnz; j++)
       68                   sum += cur_vals[j]*xv[cur_inds[j]];
       69                 yv[i] = sum;
       70               }
       71               return 0;
       72             }
