Fujitsu C/C++ Version 4.7.0   Wed Nov  2 18:23:07 2022
Compilation information
  Current directory : /lustre/home/gapinzon/arm_code/HPCG_for_Arm/ookami_fj
  Source file       : ../src/CG_ref.cpp
(line-no.)(optimize)
        1             
        2             //@HEADER
        3             // ***************************************************
        4             //
        5             // HPCG: High Performance Conjugate Gradient Benchmark
        6             //
        7             // Contact:
        8             // Michael A. Heroux ( maherou@sandia.gov)
        9             // Jack Dongarra     (dongarra@eecs.utk.edu)
       10             // Piotr Luszczek    (luszczek@eecs.utk.edu)
       11             //
       12             // ***************************************************
       13             //@HEADER
       14             
       15             /*!
       16              @file CG_ref.cpp
       17             
       18              HPCG routine
       19              */
       20             
       21             #include <fstream>
       22             
       23             #include <cmath>
       24             
       25             #include "hpcg.hpp"
       26             
       27             #include "CG_ref.hpp"
       28             #include "mytimer.hpp"
       29             #include "ComputeSPMV_ref.hpp"
       30             #include "ComputeMG_ref.hpp"
       31             #include "ComputeDotProduct_ref.hpp"
       32             #include "ComputeWAXPBY_ref.hpp"
       33             
       34             
       35             // Use TICK and TOCK to time a code section in MATLAB-like fashion
       36             #define TICK()  t0 = mytimer() //!< record current time in 't0'
       37             #define TOCK(t) t += mytimer() - t0 //!< store time difference in 't' using time in 't0'
       38             
       39             /*!
       40               Reference routine to compute an approximate solution to Ax = b
       41             
       42               @param[inout] A    The known system matrix
       43               @param[inout] data The data structure with all necessary CG vectors preallocated
       44               @param[in]    b    The known right hand side vector
       45               @param[inout] x    On entry: the initial guess; on exit: the new approximate solution
       46               @param[in]    max_iter  The maximum number of iterations to perform, even if tolerance is not met.
       47               @param[in]    tolerance The stopping criterion to assert convergence: if norm of residual is <= to tolerance.
       48               @param[out]   niters    The number of iterations actually performed.
       49               @param[out]   normr     The 2-norm of the residual vector after the last iteration.
       50               @param[out]   normr0    The 2-norm of the residual vector before the first iteration.
       51               @param[out]   times     The 7-element vector of the timing information accumulated during all of the iterations.
       52               @param[in]    doPreconditioning The flag to indicate whether the preconditioner should be invoked at each iteration.
       53             
       54               @return Returns zero on success and a non-zero value otherwise.
       55             
       56               @see CG()
       57             */
       58             int CG_ref(const SparseMatrix & A, CGData & data, const Vector & b, Vector & x,
       59                 const int max_iter, const double tolerance, int & niters, double & normr, double & normr0,
       60                 double * times, bool doPreconditioning) {
       61             
       62               double t_begin = mytimer();  // Start timing right away
       63               normr = 0.0;
       64               double rtz = 0.0, oldrtz = 0.0, alpha = 0.0, beta = 0.0, pAp = 0.0;
       65             
       66             
       67               double t0 = 0.0, t1 = 0.0, t2 = 0.0, t3 = 0.0, t4 = 0.0, t5 = 0.0;
       68             //#ifndef HPCG_NO_MPI
       69             //  double t6 = 0.0;
       70             //#endif
       71             
       72               local_int_t nrow = A.localNumberOfRows;
       73             
       74               Vector & r = data.r; // Residual vector
       75               Vector & z = data.z; // Preconditioned residual vector
       76               Vector & p = data.p; // Direction vector (in MPI mode ncol>=nrow)
       77               Vector & Ap = data.Ap;
       78             
       79    i          if (!doPreconditioning && A.geom->rank==0) HPCG_fout << "WARNING: PERFORMING UNPRECONDITIONED ITERATIONS" << std::endl;
       80             
       81             #ifdef HPCG_DEBUG
       82               int print_freq = 1;
       83               if (print_freq>50) print_freq=50;
       84               if (print_freq<1)  print_freq=1;
       85             #endif
       86               // p is of length ncols, copy x to p for sparse MV operation
       87    i          CopyVector(x, p);
       88               TICK(); ComputeSPMV_ref(A, p, Ap);  TOCK(t3); // Ap = A*p
       89               TICK(); ComputeWAXPBY_ref(nrow, 1.0, b, -1.0, Ap, r); TOCK(t2); // r = b - Ax (x stored in p)
       90               TICK(); ComputeDotProduct_ref(nrow, r, r, normr, t4);  TOCK(t1);
       91               normr = sqrt(normr);
       92             #ifdef HPCG_DEBUG
       93               if (A.geom->rank==0) HPCG_fout << "Initial Residual = "<< normr << std::endl;
       94             #endif
       95             
       96               // Record initial residual for convergence testing
       97               normr0 = normr;
       98             
       99               // Start iterations
      100             
      101               for (int k=1; k<=max_iter && normr/normr0 > tolerance; k++ ) {
      102                 TICK();
      103                 if (doPreconditioning)
      104                   ComputeMG_ref(A, r, z); // Apply preconditioner
      105                 else
      106                   ComputeWAXPBY_ref(nrow, 1.0, r, 0.0, r, z); // copy r to z (no preconditioning)
      107                 TOCK(t5); // Preconditioner apply time
      108             
      109                 if (k == 1) {
      110    i              CopyVector(z, p); TOCK(t2); // Copy Mr to p
      111                   TICK(); ComputeDotProduct_ref(nrow, r, z, rtz, t4); TOCK(t1); // rtz = r'*z
      112                 } else {
      113                   oldrtz = rtz;
      114                   TICK(); ComputeDotProduct_ref(nrow, r, z, rtz, t4); TOCK(t1); // rtz = r'*z
      115                   beta = rtz/oldrtz;
      116                   TICK(); ComputeWAXPBY_ref(nrow, 1.0, z, beta, p, p);  TOCK(t2); // p = beta*p + z
      117                 }
      118             
      119                 TICK(); ComputeSPMV_ref(A, p, Ap); TOCK(t3); // Ap = A*p
      120                 TICK(); ComputeDotProduct_ref(nrow, p, Ap, pAp, t4); TOCK(t1); // alpha = p'*Ap
      121                 alpha = rtz/pAp;
      122                 TICK(); ComputeWAXPBY_ref(nrow, 1.0, x, alpha, p, x);// x = x + alpha*p
      123                         ComputeWAXPBY_ref(nrow, 1.0, r, -alpha, Ap, r);  TOCK(t2);// r = r - alpha*Ap
      124                 TICK(); ComputeDotProduct_ref(nrow, r, r, normr, t4); TOCK(t1);
      125                 normr = sqrt(normr);
      126             #ifdef HPCG_DEBUG
      127                 if (A.geom->rank==0 && (k%print_freq == 0 || k == max_iter))
      128                   HPCG_fout << "Iteration = "<< k << "   Scaled Residual = "<< normr/normr0 << std::endl;
      129             #endif
      130                 niters = k;
      131               }
      132             
      133               // Store times
      134               times[1] += t1; // dot product time
      135               times[2] += t2; // WAXPBY time
      136               times[3] += t3; // SPMV time
      137               times[4] += t4; // AllReduce time
      138               times[5] += t5; // preconditioner apply time
      139             //#ifndef HPCG_NO_MPI
      140             //  times[6] += t6; // exchange halo time
      141             //#endif
      142               times[0] += mytimer() - t_begin;  // Total time. All done...
      143               return 0;
      144             }
      145             
